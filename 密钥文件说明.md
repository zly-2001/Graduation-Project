# 密钥文件说明

## 文件位置

```
results/keys/
├── private.pem  # 私钥文件
└── public.pem   # 公钥文件
```

## 文件生成

### 生成位置
**代码位置**：`experiments/train.py:108-119`

```python
# 预处理器（身份+时间戳+纠错+签名 -> 比特载荷），使用持久化密钥
key_dir = Path(config['save_dir']).parent / "keys"
key_dir.mkdir(parents=True, exist_ok=True)
private_key_path = key_dir / "private.pem"
public_key_path = key_dir / "public.pem"
self.preprocessor = WatermarkPreprocessor(
    private_key_path=str(private_key_path),
    public_key_path=str(public_key_path),
    target_bit_len=config['watermark_length'],
)
# 首次生成时保存密钥，便于提取端验签
if not private_key_path.exists() or not public_key_path.exists():
    self.preprocessor.save_keys(private_key_path, public_key_path)
```

### 生成时机
- **首次训练时**：如果 `private.pem` 或 `public.pem` 不存在，会自动生成
- **生成方式**：使用椭圆曲线加密算法（ECDSA，secp256k1）生成密钥对

### 生成逻辑
**代码位置**：`utils/watermark_utils.py:47-49`

```python
if self.private_key is None and self.public_key is None:
    # 自动生成新的密钥对
    self.private_key = ec.generate_private_key(ec.SECP256K1())
    self.public_key = self.private_key.public_key()
```

## 文件作用

### 1. private.pem（私钥）

**用途**：
- ✅ **训练时使用**：对水印载荷进行数字签名
- ✅ **签名过程**：在预处理阶段（S1步骤），使用私钥对BCH编码后的数据进行ECDSA签名

**代码位置**：`utils/watermark_utils.py:84-86`
```python
# ECDSA(secp256k1) 原始 r||s (64字节)
der_sig = self.private_key.sign(encoded_data, ec.ECDSA(hashes.SHA256()))
```

**安全性**：
- ⚠️ **保密**：私钥必须保密，不能泄露
- ⚠️ **不要删除**：删除后无法验证之前训练的水印

### 2. public.pem（公钥）

**用途**：
- ✅ **提取时使用**：验证水印的数字签名
- ✅ **验签过程**：在提取阶段（S64步骤），使用公钥验证签名的真实性和完整性

**代码位置**：`utils/watermark_utils.py:148`
```python
# 验签
self.public_key.verify(der_sig, encoded_data, ec.ECDSA(hashes.SHA256()))
```

**安全性**：
- ✅ **可公开**：公钥可以公开，用于验签
- ✅ **必须保留**：提取水印时必须使用对应的公钥

## 密钥对关系

```
私钥 (private.pem)  ──签名──>  水印载荷（包含签名）
                                    │
                                    │ 提取时
                                    ↓
公钥 (public.pem)   <──验签──  验证签名是否有效
```

## 是否需要删除？

### ❌ **不要删除！**

**原因**：

1. **密钥对必须匹配**
   - 训练时用私钥签名
   - 提取时用公钥验签
   - 如果删除后重新生成，**无法验证之前训练的水印**

2. **持久化设计**
   - 密钥是持久化的，一次生成，长期使用
   - 删除后需要重新训练所有数据才能验证

3. **实际应用场景**
   - 版权方使用同一对密钥长期签名
   - 提取端使用对应的公钥验证
   - 如果频繁更换密钥，无法追溯历史水印

### ✅ **正确的使用方式**

1. **首次训练**：
   - 自动生成密钥对
   - 保存到 `results/keys/`

2. **后续训练**：
   - 使用已有的密钥对
   - 保持一致性

3. **提取验证**：
   - 使用对应的 `public.pem` 验证
   - 确保密钥匹配

## 密钥管理建议

### 1. 备份密钥

```bash
# 备份密钥文件
cp -r results/keys/ results/keys_backup/
```

### 2. 版本控制

**注意**：`.gitignore` 中已排除 `results/keys/`，密钥不会提交到Git

```gitignore
# .gitignore
results/keys/
```

**原因**：私钥是敏感信息，不应提交到版本控制

### 3. 多环境使用

如果需要在不同环境（训练/测试）使用：
- 复制 `public.pem` 到提取端
- **不要**复制 `private.pem`（除非是同一版权方）

## 常见问题

### Q1: 删除密钥后重新训练会怎样？

**A**: 
- 会生成新的密钥对
- **无法验证之前训练的水印**
- 只有新训练的水印才能验证

### Q2: 可以手动生成密钥吗？

**A**: 可以，但不推荐。代码会自动生成，确保格式正确。

### Q3: 密钥文件损坏怎么办？

**A**: 
- 删除损坏的文件
- 重新运行训练，会自动生成新的密钥对
- **注意**：之前的水印将无法验证

### Q4: 多个项目可以共用密钥吗？

**A**: 
- 技术上可以
- 但建议每个项目使用独立的密钥对
- 便于管理和追溯

## 总结

| 文件 | 用途 | 是否可删除 | 说明 |
|------|------|-----------|------|
| `private.pem` | 训练时签名 | ❌ **不要删除** | 删除后无法验证历史水印 |
| `public.pem` | 提取时验签 | ❌ **不要删除** | 删除后无法验证水印 |

**最佳实践**：
1. ✅ 首次训练自动生成，之后一直使用
2. ✅ 定期备份密钥文件
3. ✅ 不要提交到版本控制（已在.gitignore中）
4. ❌ 不要删除，除非确定要重新开始

## 代码流程

### 训练时（生成/使用私钥）
```
训练开始
  ↓
检查 keys/private.pem 是否存在
  ↓
不存在 → 生成新密钥对 → 保存到 keys/
存在   → 加载已有密钥
  ↓
使用私钥对水印载荷签名
  ↓
嵌入水印
```

### 提取时（使用公钥）
```
提取开始
  ↓
加载 keys/public.pem
  ↓
提取水印载荷
  ↓
使用公钥验证签名
  ↓
返回验签结果
```
